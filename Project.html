<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>3D Cube Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #0c4a6e;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
      color: white;
      font-family: Arial, sans-serif;
    }
    #score-display {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 18px;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
      background-color: rgba(0, 0, 0, 0.3); /* Semi-transparent black background */
      font-family: Arial, sans-serif;
      font-weight: bold;
    }
    #restart-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      font-size: 18px;
      background-color: #0ea5e9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-family: Arial, sans-serif;
      font-weight: bold;
      display: none;
      z-index: 100;
    }
    #restart-button:hover {
      background-color: #0284c7;
    }
  </style>
</head>
<body>
  <div id="info">Use WASD to move, SPACE to jump<br>Avoid the cacti!</div>
  <div id="score-display">Score: 0</div>
  <button id="restart-button">Restart Game</button>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
  
    // Get restart button element
    const restartButton = document.getElementById('restart-button');

    // Create Audio object for jump sound
    const jumpSound = new Audio('./resources/SFX/Jump.mp3');
    // Create Audio object for 100 point sound
    const pointSound = new Audio('./resources/SFX/Point.wav');

    // Create scene with blue fog for depth perception
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x0c4a6e)
    scene.fog = new THREE.Fog(0x0c4a6e, 10, 50)
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    )
    camera.position.set(0, 3, 10) // Position camera for better view
  
    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    document.body.appendChild(renderer.domElement)
  
    // Controls setup - limit for gameplay
    const controls = new OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true
    controls.dampingFactor = 0.05
    controls.maxPolarAngle = Math.PI / 2 - 0.1 // Don't allow camera below ground
    controls.minDistance = 5
    controls.maxDistance = 15
    controls.target.set(0, 0, 0) // Center the controls
    
    class Box extends THREE.Mesh {
      constructor({
        width,
        height,
        depth,
        color = '#00ff00',
        velocity = {
          x: 0,
          y: 0,
          z: 0
        },
        position = {
          x: 0,
          y: 0,
          z: 0
        },
        zAcceleration = false
      }) {
        // Use MeshPhongMaterial instead of MeshStandardMaterial for better performance
        const material = new THREE.MeshPhongMaterial({ color })
        const geometry = new THREE.BoxGeometry(width, height, depth)
        super(geometry, material)
  
        this.width = width
        this.height = height
        this.depth = depth
  
        this.position.set(position.x, position.y, position.z)
  
        this.right = this.position.x + this.width / 2
        this.left = this.position.x - this.width / 2
  
        this.bottom = this.position.y - this.height / 2
        this.top = this.position.y + this.height / 2
  
        this.front = this.position.z + this.depth / 2
        this.back = this.position.z - this.depth / 2
  
        this.velocity = velocity
        this.gravity = -0.002
  
        this.zAcceleration = zAcceleration
      }
  
      updateSides() {
        this.right = this.position.x + this.width / 2
        this.left = this.position.x - this.width / 2
  
        this.bottom = this.position.y - this.height / 2
        this.top = this.position.y + this.height / 2
  
        this.front = this.position.z + this.depth / 2
        this.back = this.position.z - this.depth / 2
      }
  
      update(ground) {
        this.updateSides()
  
        if (this.zAcceleration) this.velocity.z += 0.0003
  
        this.position.x += this.velocity.x
        this.position.z += this.velocity.z
  
        this.applyGravity(ground)
      }
  
      applyGravity(ground) {
        this.velocity.y += this.gravity
  
        // this is where we hit the ground
        if (
          boxCollision({
            box1: this,
            box2: ground
          })
        ) {
          const friction = 0.5
          this.velocity.y *= friction
          this.velocity.y = -this.velocity.y
        } else this.position.y += this.velocity.y
      }
    }
  
    function boxCollision({ box1, box2 }) {
      const xCollision = box1.right >= box2.left && box1.left <= box2.right
      const yCollision =
        box1.bottom + box1.velocity.y <= box2.top && box1.top >= box2.bottom
      const zCollision = box1.front >= box2.back && box1.back <= box2.front
      return xCollision && yCollision && zCollision
    }
    
    // Player object - Use Object3D instead of Box to avoid visible geometry
    let player = new THREE.Object3D();
    player.width = 1;     // We still need these properties for collision
    player.height = 1;    // detection but we don't need the visible mesh
    player.depth = 1;
    player.velocity = {
      x: 0,
      y: -0.01,
      z: 0
    };
    player.updateSides = function() {
      this.right = this.position.x + this.width / 2;
      this.left = this.position.x - this.width / 2;
      this.bottom = this.position.y - this.height / 2;
      this.top = this.position.y + this.height / 2;
      this.front = this.position.z + this.depth / 2;
      this.back = this.position.z - this.depth / 2;
    };
    
    // Add jump flag to track if player is jumping
    player.isJumping = false;
    // To track if player is on the ground
    player.isOnGround = false;
    
    player.applyGravity = function(ground) {
      this.velocity.y += -0.002;  // gravity value
      
      // Check ground collision before movement
      const wasOnGround = this.isOnGround;

      if (
        boxCollision({
          box1: player,
          box2: ground
        })
      ) {
        const friction = 0.5;
        this.velocity.y *= friction;
        this.velocity.y = -this.velocity.y;
        this.isOnGround = true; // Player is now on ground
      } else {
        this.position.y += this.velocity.y;
        this.isOnGround = false; // Player is not on ground
      }

      // If we just landed, update animation and jump state
      if (!wasOnGround && this.isOnGround && this.isJumping) {
        this.isJumping = false;
        if (keys.a.pressed || keys.d.pressed || keys.s.pressed || keys.w.pressed) {
          setAnimation('run');
        } else {
          setAnimation('idle');
        }
      }
    };
    
    // Update player's update function to handle jump state detection
    player.update = function(ground) {
      this.updateSides();
      this.position.x += this.velocity.x;
      this.position.z += this.velocity.z;
      
      // Previous y position to detect landing
      const prevY = this.position.y;
      
      this.applyGravity(ground);
    };
    
    scene.add(player);
    
    // Animation handling system
    // Store animation actions
    player.actions = {};
    player.currentAction = null;
    player.animationState = 'idle'; // Track the current state
    
    // Function to handle animation transitions
    function setAnimation(name) {
      // If already playing this animation, do nothing
      if (player.animationState === name) return;
      
      // No animations loaded yet
      if (!player.actions || !player.mixer) return;
      
      // Get the new action
      const newAction = player.actions[name];
      const oldAction = player.currentAction;
      
      // Skip if same action or action doesn't exist
      if (newAction === oldAction || !newAction) return;
      
      // Set up crossfade
      if (oldAction) {
        newAction.time = 0;
        newAction.enabled = true;
        newAction.setEffectiveTimeScale(1);
        newAction.setEffectiveWeight(1);
        newAction.crossFadeFrom(oldAction, 0.2, true);
      }
      
      // Play the new action
      newAction.play();
      player.currentAction = newAction;
      player.animationState = name;
      
      // For jump animation, set up a callback to return to idle/run when done
      if (name === 'jump') {
        player.mixer.addEventListener('finished', function onJumpFinished(e) {
          // Return to running if movement keys are pressed, otherwise idle
          if (keys.w.pressed || keys.a.pressed || keys.s.pressed || keys.d.pressed) {
            setAnimation('run');
          } else {
            setAnimation('idle');
          }
          player.mixer.removeEventListener('finished', onJumpFinished);
        });
      }
    }
    
    // Load the dinosaur model
    const loader = new FBXLoader(); 
    loader.load('./resources/Dinosaurs/FBX/Velociraptor.fbx', (fbx) => {
      fbx.scale.set(0.0025, 0.0025, 0.0025); // Adjust size
      
      // Rotate 180 degrees to face forward
      fbx.rotation.y = Math.PI;  // Rotate 180 degrees around the Y axis
      fbx.position.y = -player.height / 2;  // Move it down by half the player's height

      const pinkMaterial = new THREE.MeshStandardMaterial({
        color: 0xFF69B4, // SaddleBrown Hex Code
        roughness: 0.6,
        metalness: 0.1
      });
      
      // Add the model to our player object
      player.add(fbx);
      
      fbx.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          child.material = pinkMaterial; // Assign brown material
        }
      });
    
      // Handle animations
      player.mixer = new THREE.AnimationMixer(fbx);
      
      // Based on your console.log(fbx.animations), we can see:
      // 0: Jump animation (index 0)
      // 2: Run animation (index 2)
      // 1: Idle animation (index 1)
      
      // Create animation actions
      player.actions = {
        idle: player.mixer.clipAction(fbx.animations[1]),  // Idle - index 1
        run: player.mixer.clipAction(fbx.animations[2]),   // Run - index 2
        jump: player.mixer.clipAction(fbx.animations[0])   // Jump - index 0
      };
      
      // Set up crossfade between animations
      for (let action in player.actions) {
        player.actions[action].clampWhenFinished = true;
        player.actions[action].setLoop(THREE.LoopRepeat);
      }
      
      // Special handling for jump (only play once)
      player.actions.jump.setLoop(THREE.LoopOnce);
      player.actions.jump.timeScale = 1.2; // Speed up jump animation a bit
      
      // Start with idle animation
      player.currentAction = player.actions.idle;
      player.currentAction.play();
    });
  
    // Ground - SMALLER SIZE
    const ground = new Box({
      width: 10,  // Reduced from 30
      height: 0.5,
      depth: 50,  // Reduced from 50
      color: '#0369a1',
      position: {
        x: 0,
        y: -2,
        z: 0
      }
    })
    ground.receiveShadow = true
    scene.add(ground)
  
    // Add a death plane below the ground
    const deathPlaneGeometry = new THREE.PlaneGeometry(30, 60);
    const deathPlaneMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xff0000,
      transparent: true,
      opacity: 0.0, // Completely invisible
      side: THREE.DoubleSide
    });
    
    const deathPlane = new THREE.Mesh(deathPlaneGeometry, deathPlaneMaterial);
    deathPlane.position.set(0, -10, 0); // Position it well below the ground
    deathPlane.rotation.x = Math.PI / 2; // Rotate to be horizontal
    
    // Add collision properties to the death plane
    deathPlane.width = 30;
    deathPlane.height = 0.1; // Thin height for collision detection
    deathPlane.depth = 60;
    deathPlane.left = deathPlane.position.x - deathPlane.width / 2;
    deathPlane.right = deathPlane.position.x + deathPlane.width / 2;
    deathPlane.bottom = deathPlane.position.y - deathPlane.height / 2;
    deathPlane.top = deathPlane.position.y + deathPlane.height / 2;
    deathPlane.front = deathPlane.position.z + deathPlane.depth / 2;
    deathPlane.back = deathPlane.position.z - deathPlane.depth / 2;
    deathPlane.updateSides = function() {
      this.left = this.position.x - this.width / 2;
      this.right = this.position.x + this.width / 2;
      this.bottom = this.position.y - this.height / 2;
      this.top = this.position.y + this.height / 2;
      this.front = this.position.z + this.depth / 2;
      this.back = this.position.z - this.depth / 2;
    };
    
    // Add a wireframe outline to make the death plane visible
    const wireframeGeometry = new THREE.EdgesGeometry(deathPlaneGeometry);
    const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
    
    deathPlane.add(wireframe);
    scene.add(deathPlane);

    // Add strong directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
    directionalLight.position.set(0, 10, 5)
    directionalLight.castShadow = true
    directionalLight.shadow.mapSize.width = 1024
    directionalLight.shadow.mapSize.height = 1024
    scene.add(directionalLight)
    
    // Add ambient light for overall illumination
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
    scene.add(ambientLight)
  
    // Input controls
    const keys = {
      a: { pressed: false },
      d: { pressed: false },
      s: { pressed: false },
      w: { pressed: false }
    }
  
    // Update the keydown event listener to handle jump animation
    window.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyA':
          keys.a.pressed = true
          if (!player.isJumping) setAnimation('run')
          break
        case 'KeyD':
          keys.d.pressed = true
          if (!player.isJumping) setAnimation('run')
          break
        case 'KeyS':
          keys.s.pressed = true
          if (!player.isJumping) setAnimation('run')
          break
        case 'KeyW':
          keys.w.pressed = true
          if (!player.isJumping) setAnimation('run')
          break
        case 'Space':
          if (player.isOnGround && !player.isJumping) {
            player.velocity.y = 0.08
            player.isJumping = true
            player.isOnGround = false
            setAnimation('jump')

            // Play jump sound effect
            jumpSound.currentTime = 0 // Reset sound to beginning
            jumpSound.play().catch(e => console.error("Error playing jump sound:", e))
          }
          break
      }
    })
  
    // Update the keyup event listener
    window.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyA':
          keys.a.pressed = false
          break
        case 'KeyD':
          keys.d.pressed = false
          break
        case 'KeyS':
          keys.s.pressed = false
          break
        case 'KeyW':
          keys.w.pressed = false
          break
      }
      
      // If no movement keys are pressed and not jumping, go back to idle
      if (!keys.a.pressed && !keys.d.pressed && !keys.s.pressed && !keys.w.pressed && !player.isJumping) {
        setAnimation('idle')
      }
    })
  
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    })

    // Cactus enemy implementation
    let cactiModels = []; // To store the loaded cactus models
    
    // Load the cactus models
    const fbxLoader = new FBXLoader();
    fbxLoader.setPath('./resources/DesertPack/FBX/');
    
    // Load all three cactus models
    const cactiToLoad = ['Cactus2.fbx', 'Cactus3.fbx'];
    let loadedCount = 0;
    
    cactiToLoad.forEach(cactusFile => {
      fbxLoader.load(cactusFile, (fbx) => {
        fbx.scale.setScalar(0.01); // Scale down the model
        
        // Apply materials and shadows
        fbx.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            // Apply a green material to make it more cactus-like
            child.material = new THREE.MeshPhongMaterial({
              color: 0x2e8b57, // Sea green color
              shininess: 0
            });
          }
        });
        
        // Store the model
        cactiModels.push(fbx);
        loadedCount++;
        
        // Clone the model for better performance
        fbx.visible = false; // Hide the original model
        scene.add(fbx); // Add to scene but keep invisible
      });
    });
    
    // Modify the enemy class to use cactus models
    class Enemy extends THREE.Object3D {
      constructor({
        width,
        height,
        depth,
        position = {
          x: 0,
          y: 0,
          z: 0
        },
        velocity = {
          x: 0,
          y: 0,
          z: 0
        },
        zAcceleration = false
      }) {
        super();
        
        this.width = width;
        this.height = height;
        this.depth = depth;
        
        this.position.set(position.x, position.y, position.z);
        
        this.right = this.position.x + this.width / 2;
        this.left = this.position.x - this.width / 2;
        
        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;
        
        this.front = this.position.z + this.depth / 2;
        this.back = this.position.z - this.depth / 2;
        
        this.velocity = velocity;
        this.gravity = -0.002;
        
        this.zAcceleration = zAcceleration;
        
        // Add a random cactus model to this enemy
        if (cactiModels.length > 0) {
          const randomIndex = Math.floor(Math.random() * cactiModels.length);
          const cactusModel = cactiModels[randomIndex].clone();
          cactusModel.visible = true;
          
          // Position the model at the center of the collision box
          cactusModel.position.y = -this.height / 2;
          
          // Add the model to this enemy object
          this.add(cactusModel);
          const cactusBoxHelper = new THREE.BoxHelper(cactusModel, 0xffff00);  // Yellow color for collision box
          cactusBoxHelper.visible = true;  // Make it visible
          this.add(cactusBoxHelper); 
        }
      }
      
      updateSides() {
        this.right = this.position.x + this.width / 2;
        this.left = this.position.x - this.width / 2;
        
        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;
        
        this.front = this.position.z + this.depth / 2;
        this.back = this.position.z - this.depth / 2;
      }
      
      update(ground) {
        this.updateSides();
        
        if (this.zAcceleration) this.velocity.z += 0.0003;
        
        this.position.x += this.velocity.x;
        this.position.z += this.velocity.z;
        
        this.applyGravity(ground);
      }
      
      applyGravity(ground) {
        this.velocity.y += this.gravity;
        
        if (
          boxCollision({
            box1: this,
            box2: ground
          })
        ) {
          const friction = 0.5;
          this.velocity.y *= friction;
          this.velocity.y = -this.velocity.y;
        } else this.position.y += this.velocity.y;
      }
    }
  
    // Function to handle game over
    function handleGameOver(reason) {
      document.getElementById('info').innerHTML = `Game Over!<br>Your score: ${score}<br>${reason}`;
      document.getElementById('info').style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
      document.getElementById('info').style.padding = '10px';
      document.getElementById('info').style.borderRadius = '5px';
      document.getElementById('score-display').style.display = 'None';
      restartButton.style.display = 'block';
      gameOver = true;
    }

    // Game state
    const enemies = []
    let frames = 0
    let spawnRate = 120
    let gameOver = false
    let score = 0;
    let scoreDisplay = document.getElementById('score-display');
    let lastScoreUpdateTime = 0
    const scoreUpdateInterval = 100 // Update score every 100ms

    // Function to update the score display
    function updateScoreDisplay() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Get the current time in milliseconds
    function getCurrentTime() {
      return new Date().getTime()
    }

    // Function to restart the game
    function restartGame() {
      // Reset game state
      gameOver = false
      score = 0
      frames = 0
      spawnRate = 120
      lastScoreUpdateTime = getCurrentTime()
      
      // Reset UI elements
      document.getElementById('info').innerHTML = 'Use WASD to move, SPACE to jump<br>Avoid the cacti!'
      document.getElementById('info').style.backgroundColor = ''
      document.getElementById('info').style.padding = ''
      document.getElementById('info').style.borderRadius = ''
      scoreDisplay.style.display = 'block'
      restartButton.style.display = 'none'
      updateScoreDisplay()
      
      // Remove all existing enemies
      enemies.forEach(enemy => {
        scene.remove(enemy)
      })
      enemies.length = 0
      
      // Reset player position and velocity
      player.position.set(0, 0, 0)
      player.velocity.x = 0
      player.velocity.y = -0.01
      player.velocity.z = 0
      player.rotation.y = 0
      player.isJumping = false
      player.isOnGround = false
      
      // Reset animation if it exists
      if (player.mixer) {
        setAnimation('idle')
      }
    }

    // Add event listener to restart button
    restartButton.addEventListener('click', restartGame)

    // Animation loop
    function animate() {
      const animationId = requestAnimationFrame(animate)
      
      // Update controls
      controls.update()
      
      // Update animation mixer if it exists
      if (player && player.mixer) {
        player.mixer.update(0.01); // Update animation with fixed time step
      }
      
      // Render scene
      renderer.render(scene, camera)
      
      if (gameOver) return
  
      // Update death plane sides
      deathPlane.updateSides();

      // Update score based on time survived
      const currentTime = getCurrentTime()
      if (currentTime - lastScoreUpdateTime >= scoreUpdateInterval) {
        if (score % 100 == 0 && score > 0) {
          // Play jump sound effect
          pointSound.currentTime = 0 // Reset sound to beginning
          pointSound.play().catch(e => console.error("Error playing point sound:", e))
        }
        score += 1 // Increase score by 1 point every 100ms
        updateScoreDisplay()
        lastScoreUpdateTime = currentTime
      }

      // Player movement
      player.velocity.x = 0
      player.velocity.z = 0
      
      // Only allow movement control if not in jumping animation
      if (keys.a.pressed) {
        player.velocity.x = -0.05
        if (!player.isJumping) {
          setAnimation('run')
          player.rotation.y = Math.PI / 2
        }
      } else if (keys.d.pressed) {
        player.velocity.x = 0.05
        if (!player.isJumping) {
          setAnimation('run')
          player.rotation.y = -Math.PI / 2 // Turn right
        }
      }

      if (keys.s.pressed) {
        player.velocity.z = 0.05
        if (!player.isJumping) {
          setAnimation('run')
          player.rotation.y = Math.PI // Face forward
        }
      } else if (keys.w.pressed) {
        player.velocity.z = -0.05
        if (!player.isJumping) {
          setAnimation('run')
          player.rotation.y = 0 // Face backward
        }
      }
      
      // If no keys are pressed and not jumping, play idle animation
      if (!keys.a.pressed && !keys.d.pressed && !keys.s.pressed && !keys.w.pressed && !player.isJumping) {
        setAnimation('idle')
      }
  
      // Update player
      player.update(ground)
      player.updateSides()
      
      // Check for collision with death plane
      if (
        boxCollision({
          box1: player,
          box2: deathPlane
        })
      ) {
        handleGameOver("You fell off the map!");
        return;
      }

      // Update enemies
      enemies.forEach((enemy) => {
        enemy.update(ground)
        if (
          boxCollision({
            box1: player,
            box2: enemy
          })
        ) {
          handleGameOver("You hit a cactus!");
        }
      })
        
      // Spawn enemies - using cactus models
      if (frames % spawnRate === 0) {
        if (spawnRate > 20) spawnRate -= 5;
    
        // Make sure we've loaded at least one cactus model
        if (cactiModels.length > 0) {
          const enemy = new Enemy({
            width: 1,
            height: 1, // Make the cacti taller for collision
            depth: 1,
            position: {
              x: (Math.random() - 0.5) * 8, // Reduced spawn area width
              y: 0,
              z: -20 // Spawn further back
            },
            velocity: {
              x: 0,
              y: 0,
              z: 0.05 + Math.random() * 0.02 // Slightly randomize speed
            },
            zAcceleration: true
          });
          
          scene.add(enemy);
          enemies.push(enemy);
        }
      }
  
      frames++
    }
    
    // Initialize the score display and start time before the game begins
    updateScoreDisplay()
    lastScoreUpdateTime = getCurrentTime()

    // Start the game
    animate()
  </script>
</body>
</html>